# 12. ESM 로딩 3단계 대화 복습 로그

[← 목차로 돌아가기](./README.md) | [← 이전: 퀴즈 복습 노트 2차](./11-quiz-review-2.md)

---

> 목적: 실제 Q&A 흐름과 이해 교정을 그대로 복습하기 위한 로그형 문서

---

## 대화 흐름 (질문 → 답변 → 이해 확인)

### 1) "ESM 로딩 3단계를 용어까지 알아야 하나?"

**질문**

> 용어까지 알아야 하는 이유가 뭔가요?

**답변 요지**

- 용어를 알아야 문제를 단계별로 정확히 분리해 설명/디버깅할 수 있음
- `Construction`: 모듈 그래프/해결 문제
- `Instantiation`: import/export 연결 문제
- `Evaluation`: 실행 순서/부작용 문제

**복습 포인트**

- 암기 목적이 아니라, 원인 분석 좌표를 맞추는 목적

---

### 2) "그래프는 미리 만들까, 로드 시작 후 만들까?"

**질문**

> ESM은 로드 시작되면 그래프를 구축하나요? 미리 구축하나요?

**답변 요지**

- 네이티브 ESM(Node/브라우저)은 보통 로드 시작 후 Construction에서 그래프 구축
- 이미 로드된 모듈은 캐시 재사용
- 번들러 빌드에서는 그래프를 미리 분석 가능

**이해 확인**

> 이미 로드되면 대부분 캐시를 사용하고, 변경 적용하려면 새로 로드해야 한다?

**확인 답변**

- 맞음 (보통 프로세스 재시작 또는 다른 specifier로 새 로드)

---

### 3) "캐시 범위는 어디까지인가?"

**질문**

> 구조 동일/내용 변경, 파일 추가, 의존성 삭제일 때 캐시가 어떻게 되나요?

**답변 요지 (Node ESM 기준)**

| 케이스                    | 같은 specifier import     | 새 specifier import |
| ------------------------- | ------------------------- | ------------------- |
| 파일 내용만 변경          | 기존 캐시 재사용 (미반영) | 변경 반영           |
| 구조 동일 + 파일 1개 추가 | 기존 캐시 재사용 (미반영) | 변경 반영           |
| 마지막 의존성 삭제        | 기존 캐시 재사용 (미반영) | 삭제 반영           |

**복습 포인트**

- 캐시 키는 해석된 URL 전체
- 쿼리(`?v=2`)가 다르면 다른 모듈로 취급

---

### 4) "브라우저 새로고침 시에는?"

**질문**

> 브라우저는 새로고침하면 어떤가요?

**답변 요지**

- 페이지 리로드 시 실행 컨텍스트는 새로 시작
- 다만 네트워크는 HTTP 캐시 영향 (`from cache`, `304`)
- Hard Reload는 일반 새로고침보다 캐시를 더 강하게 우회

**복습 포인트**

- 실행 재시작과 네트워크 캐시는 구분해서 보기

---

### 5) "모듈 그래프는 어떻게 만드나?"

**질문**

> Construction 과정을 살펴봅시다.

**답변 요지**

1. 엔트리 모듈 시작
2. 정적 import/export from 파싱
3. specifier를 실제 식별자로 resolve
4. Module Record 생성
5. 의존성 간선 추가
6. 신규 모듈이 없어질 때까지 반복

**복습 포인트**

- 정적 import가 초기 그래프 대상
- `import()`는 실행 중에 그래프 확장

---

### 6) "`resolve`의 실제 주소가 뭔가?"

**질문**

> 실제 주소(URL/파일 경로)라는 게 정확히 뭔가요?

**답변 요지**

- 런타임이 확정한 최종 식별자
- 예: 브라우저 `https://...`, Node `file:///...`, 내장 `node:fs`
- 이 식별자가 로딩 대상이자 캐시 키

---

### 7) "Module Record/간선 추가는 실제로 어떻게?"

**질문**

> "노드 만들고 A -> B 간선 추가"가 구체적으로 어떻게 되나요?

**답변 요지**

```text
moduleMap: Map<resolvedURL, ModuleRecord>

loadModule(specifier, parentURL):
  1) resolve
  2) moduleMap 조회/재사용
  3) 없으면 파싱 후 ModuleRecord 생성
  4) 자식 모듈 재귀 처리
  5) parent.dependencies에 child 추가
```

**복습 포인트**

- URL 기준으로 노드 1개 유지
- 순환 참조 대응을 위해 Record를 먼저 등록

---

### 8) "시각화로 보여달라"

**질문**

> 조금 더 이해하기 쉽게 시각화해줄 수 있나요?

**답변 예시**

```javascript
// main.mjs
import './a.mjs';
import './b.mjs';

// a.mjs
import './c.mjs';

// b.mjs
import './c.mjs';
import './d.mjs';
```

```mermaid
graph TD
  M["main.mjs"] --> A["a.mjs"]
  M --> B["b.mjs"]
  A --> C["c.mjs"]
  B --> C
  B --> D["d.mjs"]
```

**확인 포인트**

- `c.mjs`는 중복 생성되지 않고 재사용

---

### 9) "실생활 비유로 Construction"

**질문**

> Construction을 실생활 비유로 설명 가능한가요?

**답변 요지**

- 여행 계획 비유:
  - Construction = 지도/경로 설계
  - Evaluation = 실제 이동

**사용자 피드백**

> 여행 비유로는 Construction과 Instantiation 분리가 잘 안된다.

**교정 답변**

- 레벨로 분리:
  - Construction = 파일/모듈 레벨 지도 작성
  - Instantiation = 이름/바인딩 레벨 배선 연결
  - Evaluation = 실행

---

### 10) "Instantiation는 정확히 뭘 하나?"

**질문**

> 설계서를 보고 실제 연결하는 준비 과정인가요?

**답변 요지**

- 맞음
- import/export 바인딩 연결
- 없는 export import 여부 검사
- 실행 전 링크 무결성 확인

---

### 11) "사용자 이해 정리와 검증"

**사용자 정리 1**

> Construction은 설계서 작성, Instantiation은 설계서를 보고 실제 연결하여 실행 준비

**검증**

- 정확함

**사용자 정리 2**

> 장벽은 Instantiation 이후, Evaluation 이전에 생긴다

**검증**

- 정확함 (철자: `Instantiation`)

**사용자 정리 3**

> Construction은 모듈 탐색 실패, Instantiation은 이름 불일치 에러  
> `import()`는 실행 중에 확정

**검증**

- 정확함

---

### 12) 최종 이해 점검

**질문**

> 이 정도면 3단계를 이해했다고 봐도 될까요?

**답변**

- 이해했다고 봐도 됨
- 최종 체크 2개:
  - 단계별 대표 에러를 말로 구분 가능?
  - `import()`가 초기 정적 그래프가 아니라 실행 중 확장임을 설명 가능?

---

### 13) "Construction이 전제 조건인 이유는 단순히 설계서 때문?"

**질문**

> "모듈 그래프 완성이 Instantiation의 전제 조건인 이유"가  
> 결국 설계서가 있어야 실제 연결 가능해서 아닌가요?

**답변 요지**

- 핵심적으로 맞음
- 추가 이유 3개:
  - 연결 대상 확정: `import { x }`가 어느 모듈의 어떤 `export x`인지 먼저 확정해야 함
  - 실행 전 오류 검출: 누락/이름 불일치를 Evaluation 전에 발견
  - 순환 참조 처리: 사이클이 있어도 전체 바인딩 슬롯을 먼저 잡아야 링크 가능

---

### 14) "이름 검증은 Instantiation 단계가 맞나?"

**질문**

> "진짜 이름이 맞는지 확인"은 결국  
> `import { x }`가 `export x`에 연결되는 단계와 같은가요?

**답변 요지**

- 맞음 (Instantiation)
- 구분:
  - Construction: "어떤 모듈 파일인가?" 확정
  - Instantiation: "그 모듈에 그 export 이름이 있는가?" 확인 + 바인딩 연결

---

### 15) "아직 순환 참조만 남았나?"

**질문**

> 우리가 아직 얘기 안 한 게 순환 참조 처리만인가요?

**답변 요지**

- 순환 참조만 남은 건 아님
- 남은 포인트:
  - Instantiation에서 왜 "바인딩 먼저, 실행은 나중"인지의 경계/예외
  - Evaluation이 왜 leaf → root인지
  - 번들러 그래프 구축과 Construction 연결

---

### 16) "순환 참조는 Construction에서 잡히니까 전제 조건인가?"

**질문**

> 순환 참조가 존재해도 Construction에서 잡히기 때문에  
> Instantiation 전제 조건이 되는 건가요?

**답변 요지**

- 표현 보정 필요:
  - Construction은 순환 참조를 "무조건 실패 처리"하는 단계가 아님
  - 순환 구조(`A -> B -> A`)를 그래프에 포함해 모델링하는 단계
- 실제 문제(TDZ 등)는 Instantiation/Evaluation에서 드러남

---

### 17) "왜 순환 참조를 허용하나?" + 실생활 비유

**질문**

> 여전히 이해가 안 됩니다. 왜 순환 참조를 허용하나요?

**답변 요지**

- 현실 코드에서 상호 의존이 자연스럽게 생김
- 금지보다 "허용 + 안전장치(TDZ)"가 실용적
- ESM은 사이클을 모델링하고, 조기 접근은 에러로 빠르게 드러냄

**실생활 비유(회사 팀)**

- 기획팀과 데이터팀이 서로 자료를 필요로 하는 건 허용
- 다만 상대 자료가 준비되기 전에 읽으려 하면 에러

**사용자 이해 확인**

> 준비되기 전에 요구하면 양쪽 모두 에러라는 거죠?

**검증**

- 정확함

---

### 18) "Instantiation은 메모리 할당만 하고 값 공유는 안 하나?"

**질문**

> 협업 승인/연결은 끝났지만 실제 자료 공유는 Instantiation에서 안 하는 건가요?

**답변 요지**

- 학습 관점에서는 맞는 설명
- Instantiation은 연결(바인딩) 단계, top-level 실행으로 값 채우기는 Evaluation 단계
- 보정:
  - "값을 전혀 안 넣는다"는 단순화
  - 함수 선언 등 일부 예외는 존재

---

### 19) "leaf부터 실행"의 leaf가 뭔가?

**질문**

> leaf가 뭔가요?

**답변 요지**

- 의존성 그래프의 말단 모듈
- 즉, 더 이상 다른 모듈을 import하지 않는 모듈
- leaf 값부터 준비하고 상위 모듈로 올라가며 실행

---

### 20) 추가 최종 이해 점검

**질문**

> 여기까지 학습하면 ESM 로딩 3단계를 다 이해한 걸까요?

**답변 요지**

- 거의 완료
- 마무리로 남은 2개:
  - Instantiation 설명에서 예외/경계(함수 선언 등)
  - 번들러 그래프 구축과 Construction 연결

---

## 최종 한 줄

`Construction`은 "무엇을 가져올지 지도 작성", `Instantiation`은 "가져온 것을 어떻게 연결할지 배선", `Evaluation`은 "실제로 실행"입니다.

---

_작성일: 2026-02-09_  
_업데이트: 2026-02-09 (추가 Q&A 반영: 전제 조건/순환 참조/leaf/완료도 점검)_
