# 11. 퀴즈 복습 노트 2차

[← 목차로 돌아가기](./README.md) | [← 이전: Value Copy vs Live Binding 심화](./10-value-copy-vs-live-binding.md)

---

## 퀴즈 결과 요약

- **일시**: 2026-02-07
- **범위**: 01-basics ~ 10-value-copy-vs-live-binding (전 범위)
- **목적**: 1차 퀴즈(09-quiz-review) 약점 보강 + 10번 심화 문서 반영
- **응시**: Q1~Q6 (Q7~Q10 미응시)
- **점수**: 3.55 / 6 (약 59%)

### 1차 → 2차 비교

| 항목           | 1차 (02-04)  | 2차 (02-07)        |
| -------------- | ------------ | ------------------ |
| 점수           | 6.5/9 (72%)  | 3.55/6 (59%)       |
| Value Copy     | 🔴 설명 필요 | ⚠️ 인과관계 뒤바뀜 |
| ESM 3단계 용어 | ⚠️ 부분 정답 | 🔴 여전히 미암기   |
| 정적 분석      | ⚠️ 부분 정답 | ⚠️ import 쪽 누락  |

---

## Round 1: 약점 보강 (Q1~Q4)

### Q1. Value Copy 원리 — ⚠️ 부분 정답 (0.60)

**질문**: CJS에서 `mod.increment()` 2회 후 `mod.count` 출력 결과와 "객체 리터럴 평가 시점"으로 설명

**내 답변**: 0 / 객체 리터럴 평가 시점에 값이 복사되어, 복사된 값을 inc 시키므로 원본 값 변경 X

**결과 (0)**: ✅ 정답

**인과관계**: ❌ 뒤바뀜

**수정 필요**:

> ~~"복사된 값을 inc 시키므로"~~ → **increment()는 클로저로 "원본" count를 증가시킴**

정확한 인과관계:

```
1. 객체 리터럴 평가 시점에 count의 값(0)이 프로퍼티에 "스냅샷"됨
2. increment()는 클로저를 통해 "원본 변수" count를 바꿈 (0→1→2)
3. mod.count는 평가 시점의 "복사본"이라 영향 없음 → 여전히 0
```

**핵심 구분**:

| 대상                       | 가리키는 것                               |
| -------------------------- | ----------------------------------------- |
| `increment()` 안의 `count` | **원본 변수** (클로저)                    |
| `mod.count`                | **복사본** (객체 리터럴 평가 시점 스냅샷) |

---

### Q2. CJS 참조값 — 프로퍼티 수정 vs 재할당 — ✅ 정답 (0.75)

**질문**: `setValue(42)` 후 `store.state.value`와, `reset()` 후 `store.state.value` 출력

**내 답변**: 42, 42 / 재할당 불가능

**채점**: ✅ 정답

**보충 필요** — "왜 42가 유지되는지" 메커니즘:

```
setValue(42) 후:
  모듈 state ──┐
               ├──▶ { value: 42 }  ← 같은 객체
  store.state ─┘

reset() 후:
  모듈 state ──────▶ { value: 0 }  ← 새 객체 B
  store.state ─────▶ { value: 42 } ← 이전 객체 A를 여전히 가리킴
```

**한 줄 정리**: `store.state`가 **이전 객체 참조를 그대로 유지**하기 때문에 42.

---

### Q3. ESM 로딩 3단계 — 🔴 미달 (0.30)

**질문**: ESM 로딩 3단계의 영어 용어 + 각 단계 설명 + 장벽 위치

**내 답변**: 영어 용어 까먹음 / 장벽은 2~3단계 사이

**장벽 위치**: ✅ 정답
**영어 용어**: ❌ **2회 연속 미암기**

**반드시 암기 — C-I-E**:

| 단계 | 영어              | 하는 일                                              |
| ---- | ----------------- | ---------------------------------------------------- |
| 1    | **Construction**  | import 문 발견, 모듈 그래프 구축 (병렬/비동기 fetch) |
| 2    | **Instantiation** | export/import 바인딩 연결                            |
| ═══  | **장벽**          | 모든 모듈 준비 완료                                  |
| 3    | **Evaluation**    | 의존성 순서(leaf→root)대로 코드 실행                 |

> 암기 팁: **C-I-E** — "**C**onstruct 지어서 → **I**nstantiate 연결하고 → **E**valuate 실행한다"

---

### Q4. ESM 정적 분석 — import와 export 양쪽 — ⚠️ 부분 정답 (0.50)

**질문**: Tree-shaking이 가능한 이유를 import 쪽과 export 쪽 양쪽 설명

**내 답변**: 조건문 사용이 불가능하여 값이 빌드타임때 이미 확정되기때문에?

**export 쪽 설명**: ✅ (조건문 불가 → 확정)
**import 쪽 설명**: ❌ 누락

**양쪽 구분 정리**:

| 쪽         | 정적인 이유                                                |
| ---------- | ---------------------------------------------------------- |
| **import** | 파일 **최상단에만** 올 수 있음 → "누가 뭘 가져오는지" 확정 |
| **export** | **조건문 안에 못 들어감** → "뭘 내보내는지" 확정           |

```javascript
// CJS — 양쪽 다 런타임에 결정
if (cond) {
  require('./a');
} // import 쪽 불확정
module.exports = cond ? { a } : { b }; // export 쪽 불확정

// ESM — 양쪽 다 정적으로 확정
import { a } from './a.js'; // 항상 최상단
export { a, b }; // 조건문 불가
```

**핵심**: Tree-shaking은 import 쪽 + export 쪽 **둘 다** 정적이어야 가능.

---

## Round 2: 핵심 개념 확인 (Q5~Q6)

### Q5. Live Binding — 읽기 전용 — ✅ 정답 (0.70)

**질문**: `import { count } from ...` 후 `count = 99` 실행 결과

**내 답변**: 재할당 불가 에러일거같습니다

**채점**: ✅ 정답

**보충 필요**:

- 에러 타입: `TypeError: Assignment to constant variable.`
- `console.log(count)` 출력은 **1** (live binding으로 increment 반영됨)

```javascript
increment(); // 원본 count: 0 → 1
console.log(count); // 1 ← live binding이므로 최신 값 보임
count = 99; // ❌ TypeError — import한 바인딩은 읽기 전용
```

---

### Q6. Top-level await 불가 이유 — ⚠️ 부분 정답 (0.70)

**질문**: CJS에서 Top-level await 불가능한 근본 이유를 `require()` 동작과 연결

**내 답변**: CJS는 모듈마다 동기함수 래퍼가 존재하므로 top-level await 불가능

**"동기 함수 래퍼"**: ✅ 핵심 키워드
**"즉시 반환"**: ❌ 누락

**완전한 답변**:

> `require()`는 동기 함수로, 호출 즉시 `module.exports`를 **반환해야** 합니다.
> `await`는 Promise가 resolve될 때까지 실행을 멈추는데,
> `require()`는 기다릴 수 없으므로 Top-level await가 불가합니다.

---

## 미응시 문항 (Q7~Q10)

| 문항 | 주제                                            | 상태   |
| ---- | ----------------------------------------------- | ------ |
| Q7   | `__dirname` vs `process.cwd()` 실행 위치별 출력 | 미응시 |
| Q8   | Dual Package exports 설정                       | 미응시 |
| Q9   | `import.meta` 런타임별 속성                     | 미응시 |
| Q10  | ESM "바인딩 공유" 메모리 슬롯 설명              | 미응시 |

---

## 복습 우선순위

| 순위 | 주제                            | 이유                               | 상태             |
| ---- | ------------------------------- | ---------------------------------- | ---------------- |
| 1    | **ESM 로딩 3단계 C-I-E (Q3)**   | 2회 연속 미암기, 면접 빈출         | 🔴 즉시 암기     |
| 2    | **Value Copy 인과관계 (Q1)**    | 개념은 아는데 설명이 뒤바뀜        | ⚠️ 인과관계 교정 |
| 3    | **정적 분석 양쪽 설명 (Q4)**    | import 쪽 설명 습관화 필요         | ⚠️ 보충          |
| 4    | **참조값 재할당 메커니즘 (Q2)** | 결과는 맞지만 다이어그램 설명 연습 | 📚 보강          |
| 5    | **에러 타입 명시 (Q5)**         | TypeError 정확히 기억              | 📚 보강          |

---

## 다음 학습 액션

- [ ] **C-I-E 암기**: Construction → Instantiation → (장벽) → Evaluation, 3회 반복 쓰기
- [ ] **Q1 인과관계 교정**: "increment는 원본을 바꾸고, mod.count는 복사본이라 안 바뀐다" 3회 말하기
- [ ] **Q4 양쪽 연습**: "import는 최상단 고정, export는 조건문 불가 → 양쪽 정적" 반복
- [ ] Q7~Q10 응시 (다음 세션에서)
- [ ] 1주일 후(2026-02-14) 3차 퀴즈 목표: 전 문항 0.80 이상

---

_작성일: 2026-02-07_
